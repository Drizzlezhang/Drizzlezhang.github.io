<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>HotFix | Drizzlezhang&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="背景Android的项目结构越来越大，相对应出现Bug的情况也越来越多，传统机制下每当出现一个紧急Bug都必须重新打包、测试、发布，用户需要下载、覆盖安装,成本很高，所以很多团队都在寻找方法，通过补丁的形式修复Bug，不用重新发布再让用户下载安装。
我们的Android客户端目前的问题是一些比较重要的逻辑（比如支付），在出现Bug的时候需要及时修复，等不及再发一个包到市场上等着用户手动安装更新，所">
<meta property="og:type" content="article">
<meta property="og:title" content="HotFix">
<meta property="og:url" content="http://yoursite.com/2016/07/02/HotFix/index.html">
<meta property="og:site_name" content="Drizzlezhang's blog">
<meta property="og:description" content="背景Android的项目结构越来越大，相对应出现Bug的情况也越来越多，传统机制下每当出现一个紧急Bug都必须重新打包、测试、发布，用户需要下载、覆盖安装,成本很高，所以很多团队都在寻找方法，通过补丁的形式修复Bug，不用重新发布再让用户下载安装。
我们的Android客户端目前的问题是一些比较重要的逻辑（比如支付），在出现Bug的时候需要及时修复，等不及再发一个包到市场上等着用户手动安装更新，所">
<meta property="og:updated_time" content="2016-07-02T09:26:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HotFix">
<meta name="twitter:description" content="背景Android的项目结构越来越大，相对应出现Bug的情况也越来越多，传统机制下每当出现一个紧急Bug都必须重新打包、测试、发布，用户需要下载、覆盖安装,成本很高，所以很多团队都在寻找方法，通过补丁的形式修复Bug，不用重新发布再让用户下载安装。
我们的Android客户端目前的问题是一些比较重要的逻辑（比如支付），在出现Bug的时候需要及时修复，等不及再发一个包到市场上等着用户手动安装更新，所">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://ww3.sinaimg.cn/large/a61009a8jw1f2be34ug4rj208i08idg0.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Drizzle Zhang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">野蛮生长，不忘初心</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Drizzle Zhang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="http://ww3.sinaimg.cn/large/a61009a8jw1f2be34ug4rj208i08idg0.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Drizzle Zhang</h1>
			</hgroup>
			
			<p class="header-subtitle">野蛮生长，不忘初心</p>
			
			<nav class="header-menu">
				<ul>
				
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-HotFix" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/02/HotFix/" class="article-date">
  	<time datetime="2016-07-02T09:25:11.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HotFix
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Android的项目结构越来越大，相对应出现Bug的情况也越来越多，传统机制下每当出现一个紧急Bug都必须重新打包、测试、发布，用户需要下载、覆盖安装,成本很高，所以很多团队都在寻找方法，通过补丁的形式修复Bug，不用重新发布再让用户下载安装。</p>
<p>我们的Android客户端目前的问题是一些比较重要的逻辑（比如<strong>支付</strong>），在出现Bug的时候需要及时修复，等不及再发一个包到市场上等着用户手动安装更新，所以需要引入一套HotFix的机制。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>现在流行的HotFix方案的原理基本是一致的，主要就是依靠Android的<code>ClassLoader</code>机制。Android中加载类一般用两种：</p>
<p><code>PathClassLoader</code></p>
<blockquote>
<p>Provides a simple {@link ClassLoader} implementation that operates<br>on a list of files and directories in the local file system, but<br>does not attempt to load classes from the network. Android uses<br>this class for its system class loader and for its application<br>class loader(s).</p>
</blockquote>
<p><code>DexClassLoader</code>.</p>
<blockquote>
<p>A class loader that loads classes from {@code .jar} and<br>{@code .apk} files containing a {@code classes.dex} entry.<br>This can be used to execute code not installed as part of an application.</p>
</blockquote>
<p>这两个类都继承自<code>BaseDexClassLoader</code>，再看这个父类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String originalPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.originalPath = dexPath;</span><br><span class="line">        <span class="keyword">this</span>.pathList =</span><br><span class="line">            <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = pathList.findClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看<code>DexPathList</code>的<code>findClass</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            DexFile dex = element.dexFile;</span><br><span class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>再看<code>DexFile</code>的相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, mCookie);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>BaseDexClassLoader</code>类里有一个<code>pathList</code>对象，这个对象其实就是一个包含多个DexFile的有序集合，加载类的时候其实就是按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找类则返回，如果找不到从下一个dex文件继续查找。所谓的HotFix其实就是在这个过程中，把修改后的类文件打包一个dex文件，插入到<code>pathList</code>的第一个位置，在这个过程中如果出现了重复的类，最终会使用第一个找到的类，所以这时候目标类就已经被替换掉了。</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><h4 id="CLASS-ISPREVERIFIED"><a href="#CLASS-ISPREVERIFIED" class="headerlink" title="CLASS_ISPREVERIFIED"></a><code>CLASS_ISPREVERIFIED</code></h4><p>如果不加处理使用以上的方法，那么在加载补丁的时候首先会出现这个异常：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation</span><br></pre></td></tr></table></figure></p>
<p>因为在DexPrepare.cpp将dex转化成odex的过程中，会在DexVerify.cpp进行校验，验证如果static方法、private方法、构造函数等，直接引用到的类（第一层级关系，不会进行递归搜索）和当前类是否在同一个dex，如果是，则会打上<code>CLASS_ISPREVERIFIED</code>标志。所以要想办法阻止相关类被打上<code>CLASS_ISPREVERIFIED</code>标志。<br>最直接的方法就是改变代码结构，使要热修复的类引用其他dex中的类，当然这样灵活性就降低了。因为bug无处不在，出现bug的时候我们是不知道要修复哪些类的。<br>另外就是用工具javassist或者ASM进行动态代码注入。</p>
<h4 id="Android-6-0以上的权限"><a href="#Android-6-0以上的权限" class="headerlink" title="Android 6.0以上的权限"></a>Android 6.0以上的权限</h4><p>因为在6.0以后一些敏感权限是需要动态申请的，热修复因为都需要下载或者生成一个patch补丁包放在本地，所以是需要在这时候申请读写SD卡这一组权限的。</p>
<h4 id="ProGuard"><a href="#ProGuard" class="headerlink" title="ProGuard"></a>ProGuard</h4><p>在给目标类进行动态代码注入的时候，是通过反射根据包名和类名获取Class的，如果这时候代码已经被混淆的话，包名和类名都发生了变化，这个获取过程出错的几率比较大。</p>
<h2 id="HotFix"><a href="#HotFix" class="headerlink" title="HotFix"></a>HotFix</h2><p>我使用的框架是GitHub上dodola的<a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a>这个项目，同类的项目有<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a>,在Android端进行热修复的实现思路都是类似的。这一部分看项目源码就可以。</p>
<p>如何解决<code>CLASS_ISPREVERIFIED</code>的问题？<br>文档里说的比较清楚了：</p>
<blockquote>
<p>解决的方法就是在类中引用一个其他dex中的类，但是源码方式的引用会将引用的类打入同一个dex中，所以我们需要找到一种既能编译通过并且将两个互相引用的类分离到不同的dex中，于是就有了这个动态的代码植入方式。</p>
</blockquote>
<h2 id="不同解决方案的比较"><a href="#不同解决方案的比较" class="headerlink" title="不同解决方案的比较"></a>不同解决方案的比较</h2><h4 id="HotFix-1"><a href="#HotFix-1" class="headerlink" title="HotFix"></a><a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a></h4><ul>
<li>代码虽然写的比较死，但是容易理解，可定制性强</li>
<li>在打包的时候就需要给目标类动态注入代码，相当于打一个TAG，避免出现<code>CLASS_ISPREVERIFIED</code>的问题。如果给项目所有的类都这么做的话工作量比较大。而且补丁也需要自己制作。</li>
</ul>
<h4 id="Nuwa"><a href="#Nuwa" class="headerlink" title="Nuwa"></a><a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a></h4><ul>
<li>自动化做的比较好，制作补丁有专门的gradle插件。</li>
<li>坏消息是作者似乎不准备再维护这个项目了，所以gradle版本升级之后它的gradle插件就不能用了。GitHub上一些人提了issue作者也不准备解决了，坑比较多。</li>
</ul>
<h4 id="DroidFix"><a href="#DroidFix" class="headerlink" title="DroidFix"></a><a href="https://github.com/bunnyblue/DroidFix" target="_blank" rel="external">DroidFix</a></h4><ul>
<li>原理和HotFix一致，包括对<code>CLASS_ISPREVERIFIED</code>的处理方法。</li>
<li>对接口的热修复支持不好。</li>
<li>这个项目的源码我没仔细看，有待研究。</li>
</ul>
<h4 id="RocooFix"><a href="#RocooFix" class="headerlink" title="RocooFix"></a><a href="https://github.com/dodola/RocooFix" target="_blank" rel="external">RocooFix</a></h4><ul>
<li>HotFix的作者的另一个项目，支持重启热修复和实时热修复。实时热修复用的是另一个开源项目<a href="https://github.com/asLody/legend" target="_blank" rel="external">Legend</a>。我们暂且只用重启热修复这部分代码。</li>
<li>按照项目描述的是无需关注混淆问题，无需手动制作补丁，而且作者在及时填坑。</li>
</ul>
<h2 id="补丁版本管理"><a href="#补丁版本管理" class="headerlink" title="补丁版本管理"></a>补丁版本管理</h2><p>阿里的<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a>现在给出的方案是每个补丁对应的文件中有个Create-Time的字段，根据这个字段按照顺序打补丁。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>目前的方案，补丁是下载下来放在本地一个目录下的，用户是可以手动替换掉补丁的。可以通过对补丁包的MD5进行验证避免补丁被恶意替换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>我们目前的项目实现热修复的话，用今天讲的这种原理理论上就可以了。</li>
<li>因为现在项目代码不混淆，所以不需要考虑这方面的问题。但是项目现在使用第三方加固的话，尚不清楚加固的原理，根据一些用过热修复的人说的，一些第三方加固会将Android原有的<code>PathClassLoader</code>替换为他们自己的<code>loader</code>，这样的话就需要做单独处理了。</li>
<li><code>CLASS_ISPREVERIFIED</code>用目前通用的动态注入字节码的方式就可以处理。</li>
<li>本地制作补丁包实现自动化写一个脚本或者gradle插件。</li>
<li>多个补丁的版本管理和安全问题也需要后端的配合。</li>
<li>紧急情况可以使用这个方案，一次加载多个dex补丁必然导致性能的问题。</li>
<li>其他的问题只能是在项目里真正使用之后再寻求解决方案了。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.infoq.com/cn/articles/ctrip-android-dynamic-loading" target="_blank" rel="external">携程Android App插件化和动态加载实践</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect" target="_blank" rel="external">安卓App热补丁动态修复技术介绍</a></li>
<li><a href="http://my.oschina.net/853294317/blog/308583" target="_blank" rel="external">Android dex分包方案</a></li>
<li><a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="external">美团Android DEX自动拆包及动态加载简介</a></li>
<li><a href="http://kymjs.com/code/2016/05/08/01" target="_blank" rel="external">Android 热修复，没你想的那么难</a></li>
</ul>
<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><ul>
<li><a href="https://github.com/CtripMobile/DynamicAPK" target="_blank" rel="external">携程DynamicAPK</a></li>
<li><a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="external">奇虎360 DroidPlugin</a></li>
<li><a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">阿里AndFix</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/05/24/About-Me/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">About Me</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Drizzle Zhang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: undefined,
		mathjax: undefined,
		animate: undefined,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






  </div>
</body>
</html>