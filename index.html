<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Drizzlezhang&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="张毛雨的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Drizzlezhang's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Drizzlezhang's blog">
<meta property="og:description" content="张毛雨的Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Drizzlezhang's blog">
<meta name="twitter:description" content="张毛雨的Blog">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://ww3.sinaimg.cn/large/a61009a8jw1f2be34ug4rj208i08idg0.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Drizzle Zhang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">野蛮生长，不忘初心</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Drizzle Zhang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="http://ww3.sinaimg.cn/large/a61009a8jw1f2be34ug4rj208i08idg0.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Drizzle Zhang</h1>
			</hgroup>
			
			<p class="header-subtitle">野蛮生长，不忘初心</p>
			
			<nav class="header-menu">
				<ul>
				
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="_posts-Retrofit源码分析" class="article article-type-_posts" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/27/Retrofit源码分析/" class="article-date">
  	<time datetime="2017-04-27T12:39:03.000Z" itemprop="datePublished">2017-04-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/27/Retrofit源码分析/">Retrofit源码分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>最近把之前看过的Retrofit的源码翻出来研究一下。</p>
<p>Retrofit现在不像两年前是个新鲜事物，大版本已经到Retrofit2了，越来越多的新项目和开源项目会理所应当地使用OkHttp + Retrofit + RxJava + Gson这一套进行网络请求，这也侧面反映了Retrofit的强大（<em>插一句，这几个库厉害不代表会用就厉害，其实用了就知道，这几个的搭配使用的优势就是傻瓜化</em>）。优秀的框架在使用和扩展上会越来越简单，同时又会更强大，在我看来Retrofit相对于Volley以及更早的框架就是这样。而这时候只会用是不够的，知其然且知其所以然，才能真正学到本事。</p>
<p>这篇分析基于Retrofit2.2.0。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>这里就不自己画了，借助stay大神的图，毕竟这张图画的太完美了：</p>
<p><img src="https://blog.piasy.com/img/201606/retrofit_stay.png" alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>还是以官方的示例代码来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="annotation">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口用过Retrofit的都算是很熟了，然后再用Retrofit创建一个接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<p>这里是一个明显的建造者模式+外观模式，也算是如今许多开源项目的套路了。然后是进行网络请求了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure>
<p>官网的示例到此结束，一般情况下使用Retrofit都是这么个套路，最多就是在配置时加上Gson或者RxJava。接下来我们开始分析源码，还是从入口开始，关键点在创建API实例的<code>create(class)</code>方法，我们看这部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我刚开始看的时候完全不明白，在查了<code>InvocationHandler</code>相关的知识之后才了解这里用到了Java的动态代理技术。在这里，就是动态生成我们所写的API接口的实现类，创建一个实例，然后把对方法的调用转发给new出来的<code>InvocationHandler</code>，在<code>invoke</code>方法中执行接口实现类的逻辑。<br>然后我们再看其中的具体逻辑。第一步中源码有注释，如果调用的是Object类的方法（toString这些），那就直接调用。第二步如果是default方法就调用default方法，这个default方法来自Java8，具体见这篇<a href="http://ebnbin.com/2015/12/20/java-8-default-methods/" target="_blank" rel="external">Java8 默认方法</a>。然后就是关键部分了，因为我们在使用的时候不可能是前两种情况，我们调用的都是我们自己写的接口的方法，接下来这几行代码就是请求的具体过程了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>loadServiceMethod</code>方法里创建了一个<code>ServiceMethod</code>的实例，并且在中间实现了缓存逻辑。然后再看<code>ServiceMethod</code>里的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">  <span class="keyword">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">  <span class="keyword">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">  <span class="keyword">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">  <span class="keyword">this</span>.httpMethod = builder.httpMethod;</span><br><span class="line">  <span class="keyword">this</span>.relativeUrl = builder.relativeUrl;</span><br><span class="line">  <span class="keyword">this</span>.headers = builder.headers;</span><br><span class="line">  <span class="keyword">this</span>.contentType = builder.contentType;</span><br><span class="line">  <span class="keyword">this</span>.hasBody = builder.hasBody;</span><br><span class="line">  <span class="keyword">this</span>.isFormEncoded = builder.isFormEncoded;</span><br><span class="line">  <span class="keyword">this</span>.isMultipart = builder.isMultipart;</span><br><span class="line">  <span class="keyword">this</span>.parameterHandlers = builder.parameterHandlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>ServiceMethod</code>的构造方法，我们基本能知道这个类的成员变量都有哪些。首先看我们比较眼熟的两个成员变量，<code>responseConverter</code>和<code>callAdapter</code>,因为搭配使用过RxJava + Retrofit + Gson的人都知道在创建Retrofit实例的时候是这么写的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(baseUrl)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>先看 <code>ServiceMethod</code>里<code>callAdapter</code>相关的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; createCallAdapter() &#123;</span><br><span class="line">  Type returnType = method.getGenericReturnType();</span><br><span class="line">  <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个成员变量的<code>callAdapter</code>还是有<code>Retrofit</code>来提供，在<code>Retrofit</code>类内部有这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">  <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">    Annotation[] annotations) &#123;</span><br><span class="line">  checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">  checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate call adapter for "</span>)</span><br><span class="line">      .append(returnType)</span><br><span class="line">      .append(<span class="string">".\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">      builder.append(<span class="string">"\n   * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    builder.append(<span class="string">"\n   * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里会遍历一个<code>CallAdapter.Factory</code>的列表，知道找到可用的工厂，我们在构建<code>Retrofit</code>时传入的<code>RxJavaCallAdapterFactory</code>就是在这里要使用的。然后再看<code>responseConverter</code>这个成员变量的相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123;</span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来还是由<code>Retrofit</code>来提供：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123;</span><br><span class="line">  <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(Converter.Factory skipPast,</span><br><span class="line">    Type type, Annotation[] annotations) &#123;</span><br><span class="line">  checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">  checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">        converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate ResponseBody converter for "</span>)</span><br><span class="line">      .append(type)</span><br><span class="line">      .append(<span class="string">".\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">      builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体逻辑毫无二致。<br><code>ServiceMethod</code>里另外两个比较关键的成员变量分别是<code>callFactory</code>和<code>parameterHandlers</code>，<code>callFactory</code>本质是<code>okhttp3.Call.Factory</code>,在<code>Retrofit</code>的构建过程中也可以传入自己实现的<code>okhttp3.Call.Factory</code>，如果没有，则会默认创建一个<code>OkHttpClient</code>。再看<code>parameterHandlers</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">    <span class="keyword">int</span> p, Type parameterType, Annotation[] annotations) &#123;</span><br><span class="line">  ParameterHandler&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(</span><br><span class="line">        p, parameterType, annotations, annotation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (annotationAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"Multiple Retrofit annotations found, only one allowed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = annotationAction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们我们在写业务层的API时都是通过注解传入参数的，它的作用就是解析每个参数使用的注解类型并进行处理。到这里<code>ServiceMethod</code>这部分基本解释结束。在这个类里面，核心的就是三个工厂：<code>okhttp3.Call.Factory</code>、<code>CallAdapter.Factory</code>和<code>Converter.Factory</code>，核心的模块全部交给工厂来做，外界可以通过传入自己的工厂实现对流程的完全控制，真正做到了高内聚低耦合（<em>虽然在我看来<code>okhttp3.Call.Factory</code>还是有点强依赖于OkHttp</em>）。<br><code>ServiceMethod</code>看完了，再看<code>OkHttpCall</code>。它实现了<code>retrofit2.Call</code>接口，<code>execute()</code>和<code>enqueue(callback)</code>这两种请求都是在这里来做。先看<code>execute()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">        creationFailure = e;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = serviceMethod.toRequest(args);</span><br><span class="line">  okhttp3.Call call = serviceMethod.callFactory.newCall(request);</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse = rawResponse.newBuilder()</span><br><span class="line">      .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    rawBody.close();</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>execute()</code>方法里的代码并不多，其实就是一个构造请求、请求网络、解析返回数据的过程。在<code>createRawCall()</code>的时候就可以用<code>serviceMethod</code>的<code>callFactory</code>来构造具体请求。在处理返回数据的时候<code>responseConverter</code>也就派上了用场。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callback == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  Throwable failure;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    failure = creationFailure;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        failure = creationFailure = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">    callback.onFailure(<span class="keyword">this</span>, failure);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      Response&lt;T&gt; response;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = parseResponse(rawResponse);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      callSuccess(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看起来长，但是大体逻辑与同步请求没有本质区别，只是在异步的callback里进行返回数据的处理。到这里，一次完整的请求就完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实<code>Retrofit</code>的诱人之处完全不止于此，许多人使用<code>Retrofit</code>都是冲着<code>RxJavaCallAdapterFactory</code>和<code>GsonConverterFactory</code>去的，如果有更深的兴趣，可以读一下这些<code>Factory</code>的具体实现的代码，因为不只有<code>RxJavaCallAdapterFactory</code>和<code>GsonConverterFactory</code>这两个，还有<code>Java8CallAdapterFactory</code>和<code>JacksonConverterFactory</code>这些工厂。当然我们也可以根据需求写我们自己的工厂。另外<code>Retrofit</code>里的<code>CallAdapter</code>默认使用的是OkHttp，我们完全也可以用其他的框架替代OkHttp。<code>Retrofit</code>除了充足的扩展性，另一个就是它对设计模式的灵活运用，包括刚开始提到的门面模式，建造者模式，还有工厂模式，另外在这些工厂的具体实现里还有策略模式和装饰模式。具体可以看这一篇<a href="http://www.jianshu.com/p/fb8d21978e38" target="_blank" rel="external">Retrofit分析-经典设计模式案例</a>。总之，<code>Retrofit</code>确实是一个优质的网络封装库，而且它用不多的代码却实现了模块的完全解耦和充分的扩展性，源码很值得一读。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_posts-阅读源码的半程总结-读源码都读什么" class="article article-type-_posts" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/23/阅读源码的半程总结-读源码都读什么/" class="article-date">
  	<time datetime="2017-04-23T11:08:04.000Z" itemprop="datePublished">2017-04-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/23/阅读源码的半程总结-读源码都读什么/">阅读源码的半程总结-读源码都读什么</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>讲完了为什么要读源码，然后再说读源码都读什么。我应该不会写怎么读的问题了，毕竟看代码跟写代码不一样，属于一个很玄学的东西，每个人都有自己的一套思路。</p>
<p>那么读源码都读什么？说到底也就是读源码能学到什么？从我自己的角度，大概能分为几个角度：学习优秀的解决方案；学习优秀的代码风格；学习设计模式的使用场景；学习搭架构的思路；学习一些平时没见过和想不到的黑科技。</p>
<h2 id="学习优秀的解决方案"><a href="#学习优秀的解决方案" class="headerlink" title="学习优秀的解决方案"></a>学习优秀的解决方案</h2><p>这个算是读源码比较功利也比较实际的用途。同一个需求永远都会有不同的解决方案，这时候就可以通过看类似框架的源码来搞清楚最成熟的解决方案是什么。一个简单的例子，在我们现有的项目中图片选择器采用了获取图片和视频绝对路径的方案，最终为了显示视频缩略图，我还必须定制一下Glide。但是知乎最近开源的Matisse，获取的就是图片和文件content:// 格式的URL，Glide在解析这种路径有对应的MediaStoreStreamLoader,完美解决了展示视频缩略图的问题。虽然同样解决了问题，但是Matisse解决的似乎就更加优雅。</p>
<h2 id="学习优秀的代码风格"><a href="#学习优秀的代码风格" class="headerlink" title="学习优秀的代码风格"></a>学习优秀的代码风格</h2><p>只学代码风格，我个人觉得最好读一些通用的、底层的东西。比如Java的代码风格，那就去读JDK一些常用类，Js的代码风格，我个人可能就会看看经典的jQuery或者vue.js。没有什么三方库的代码会比它们的代码更简洁，使用更准确。</p>
<h2 id="学习设计模式"><a href="#学习设计模式" class="headerlink" title="学习设计模式"></a>学习设计模式</h2><p>写代码过了初级阶段，多多少少都会开始用到设计模式，无论是刻意还是无意。可是设计模式那么多种，书里教了这是怎么回事，到了真正设计架构的时候，却不知道该用哪种了。简单的单例模式、建造者模式、工厂方法模式就不说了，基本都是固定的套路和使用场景。但是到了稍微复杂点的，我是确实不清楚该不该用，该用哪种，该怎么用。用少了，代码不解耦，扩展性差，不好维护。用多了，变成了“面向设计模式编程”，代码量成倍扩张，却没做多少事。这时候就有优质的源码给我们铺路了。</p>
<p>在被动读了OkHttp之后，我后来又主动重读了一遍。大家都知道Interceptor是OkHttp一个很强大的接口，利用这个接口几乎可以在一个完整的请求中做任何事情。但是其实在OkHttp内部也是用Interceptor做了重定向、连接服务器、发送和接收请求以及缓存这些事情，连在一起，就是一个责任链模式。</p>
<p>在项目里我没有用过Picasso，但是因为它和Glide使用方法的相似性，我花时间看了它的源码。然后我才发现Picasso和Glide完全走了两个极端，Picasso算是大道至简，只有一个包，能不做的事情都不做，所有目的都只为图片的加载。而Glide则开放了所有的接口，所有步骤都可以定制，甚至可以像我那样为具体需求增加自己的feature。但是为什么我们会觉得他们用起来差不多呢？说到底他们都用了外观模式，我们在调用的时候只知道拿起Glide和Picasso开始用，其他的工作都交给内部去做了。</p>
<p>而我读过的源码中设计模式的集大成者，应该是Retrofit了。这个库的源码不多不少，但是加上配套的一堆Adapter和Convertor，外观模式、代理模式、策略模式、适配器模式、装饰模式都用到了，甚至同一个接口不同的实现都可以用到不同的设计模式。完全解耦，所有步骤与Glide一样都可以定制。</p>
<p>对于设计模式的学习，我个人的感受还是应该多看多写才能真正掌握并最终能够游刃有余，而优秀的源码可是说是提供了最完美的解决方案。</p>
<h2 id="学习搭架构的思路"><a href="#学习搭架构的思路" class="headerlink" title="学习搭架构的思路"></a>学习搭架构的思路</h2><p>从做Android开发来说，每个项目最常用的就是网路库和图片库了。如果能从零设计这两个库，那么其他的架构都是大同小异了。</p>
<p>以网络库Volley为例，读完源码，基本能形成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;Request --&#62; Dispatcher --&#62; Cache --&#62; HttpStack</span><br></pre></td></tr></table></figure>
<p>这一套思路。其实再看其他的网路库都大同小异。我们自己实现，根据这个思路基本就足够了。</p>
<p>再以Glide为例，整个架构基本是由RequestManager、Engine、Cache、Target这几部分组成，其他的也是差不多的思路。</p>
<p>优质的库都是在大量试错和妥协后的结果，基本是用最合理的方式实现最终的需求，在设计类似的框架时，先借鉴，再改进，设计其他的架构差不多也是这么一套方法。</p>
<h2 id="学习一些黑科技"><a href="#学习一些黑科技" class="headerlink" title="学习一些黑科技"></a>学习一些黑科技</h2><p>这个就属于堆经验了。同样类型的库架构上大同小异，但是每个库又有它的独到之处，只有真正把源码读完，才能学习到有意思的地方。这部分只举例子，不具体分析：</p>
<ul>
<li><p>Glide利用一个空Fragment的生命周期实现每个请求与所属上下文生命周期的绑定</p>
</li>
<li><p>RecyclerView不再像ListView那样缓存View，二是直接缓存ViewHolder，这是许多仿写ListView的人从没想到过的思路</p>
</li>
<li><p>Retrofit使用动态代理拿到注解的请求详情</p>
</li>
<li><p>OkHttp的责任链模式 <em>虽然是个设计模式，但是这个思路太巧妙了</em></p>
</li>
<li><p>Picasso的磁盘缓存本质上是OkHttp的磁盘缓存！当时看到这部分源码是特别惊艳的，同时我也感受到了Square的工程师们对他们的全家桶的无比自信</p>
</li>
</ul>
<p>这些有意思的设计细节我们不一定能用得到，但是能为我们解决平时的问题提供更多的思路，同时也能学到更多不常用的知识。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了这些提到的库，其他一些源码我也多少度过，只能说代码神奇就在这里，每个人的代码风格、设计思路都不一样，但是最终都能产出一个优质的开源框架，很多苦看起来架构差不多，但是内部实现又是千奇百怪，同一种模块似乎每种设计模式都能派上用场。读源码，抛去为了解决问题、为了提升技能的这些功利性的想法，只是体会这些强人的思路，已经是一种享受了吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_posts-阅读源码的半程总结-为什么要阅读源码" class="article article-type-_posts" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/22/阅读源码的半程总结-为什么要阅读源码/" class="article-date">
  	<time datetime="2017-04-22T06:42:48.000Z" itemprop="datePublished">2017-04-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/22/阅读源码的半程总结-为什么要阅读源码/">阅读源码的半程总结-为什么要阅读源码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我工作时间并不长，阅读的源码也不够多，这篇文章只能说是算是对自己这方面的一个总结，或者更多的是从我工作和做Android这方面的角度分析问题。至于为什么是半程总结，因为以后有了新的感受和技能，肯定还要回头来更新。</p>
<p>为什么要读源码？我觉得其实很多人都没有答案。</p>
<p>我见过最多的，可能就是对一个函数的使用不清楚，Android完全开源，点进去看看这个方法干了啥，可能抛出什么异常，撑死了再看一下注释，这也就算是读过源码了。</p>
<p>可能是我自己现在做Android开发的原因？或者是现在编程语言和框架发展太快？好像我见过的许多人都热衷于学习新框架的用法，做一个项目就等同于推依赖库。我见过知乎的一个问题：<a href="https://www.zhihu.com/question/34452706" target="_blank" rel="external">现在android开发都会用到那些快速开发框架或者第三库？</a>。去年的这个时候看到这个问题下面的回答我可能就是会心一笑，因为我也这么做，毕竟初级工程师嘛，哪考虑那么多？GitHub上的star数也能反映很大的问题，一个项目用个RxJava+Retrofit+MD+Dagger+MVP，当然，像OkHttp、Glide、ButterKnife这些已经是必备了，然后写一篇文章宣传下，star数就蹭蹭得涨，我之前闲的时候clone个几个项目看过代码，实话说代码质量真不敢恭维。把这几个库放在一个成熟项目的团队里让大家用，首先，你能保证API是Restful么？你能保证大家都能接受RxJava的学习曲线么，换句话说，学了RxJava的几个操作符，就真的明白什么是响应式编程了么？你能承担项目整体重构成MVP结构的风险么？这几个库都是现在Android开发很棒的库，都是很“潮”的东西，但是不客气的说，除了RxJava学习曲线比较抖，其他这些库现在都是傻瓜式使用，全都有完整的官方文档和Wiki，真的是要啥有啥，只学这些库的使用的话真的没有什么成本。</p>
<p>吐槽完毕，言归正传。我把读源码分为三种情况：为了修复bug被动阅读，为了技术选型去主动阅读，为了提升自己去阅读。</p>
<h2 id="被动阅读源码"><a href="#被动阅读源码" class="headerlink" title="被动阅读源码"></a>被动阅读源码</h2><blockquote>
<p>以下是本人上OkHttp的真实经历</p>
</blockquote>
<p>被动就是现在在你的主导下，上了一个新依赖库，你在上线之前做了充分的工作，前期做了社区调研，了解了大家对这个库的各种看法，通读了wiki，甚至看了很多issue，接着在引入项目的时候做了极致的封装，保证与业务代码完全解耦，唯独没有读源代码，毕竟这是件费力不讨好的事儿。万事俱备，上线！然后，你从没有见过的各种bug就接踵而至，很多bug都Google不到，Wiki也不会说我们这个库有啥啥啥的毛病，万幸还有错误栈可以看，没办法了，锅是你的，看源代码虽然像便秘，也只能硬着头皮上啦！</p>
<p>这时候就开始被动读源码了。一般来说，大多数bug只要根据错误信息，看看是哪个函数抛出来的错误，再循着传递的参数找到底，问题差不多就能解决了。但是总有那种问题，看起来不是你用的库抛出来的，之前从来没出过，只有你的这个版本有，还特别多，别人不由得就怀疑是你的锅，即使是为了自证清白（一般都不清白），也得把问题的根源找到然后解决了。这是一个最痛苦的过程，对于一个影响全局的库来说，任何地方都有可能出问题，到这里，通读源码就是唯一的办法了，任何库都有妥协和脏代码，只有从这部分东西才能猜出问题出在哪里。</p>
<p>因为这部分问题的解释涉及到我们一部分核心业务逻辑，就不多讲了。只能说如果一个影响全局的库已经成功在一个项目了稳定运行多年，已经调试到没有问题的状态，除非一些强制客观因素必须换功能更强大的库，否则一定要谨慎。</p>
<h2 id="主动阅读源码"><a href="#主动阅读源码" class="headerlink" title="主动阅读源码"></a>主动阅读源码</h2><blockquote>
<p>以下是本人上Glide的真实经历</p>
</blockquote>
<p>吸取了上面的教训，在换Glide的之前我主动通读了Glide的源代码，即便如此，我也没敢擅自动手。Android最怕的就是莫名其妙的OOM，而换图片加载库则可能会爆发大量的OOM，这时候读完代码也没用，只能用笨方法一步一步去检测内存问题。但是后来我们要全局支持gif格式，而UIL没有这个功能，也没法做扩展，这时候就只能上Glide了。</p>
<p>Glide相对于UIL是比较新的，功能也更多，读完源码之后也被它强大的扩展性震惊了。图片从发起请求到最终展示，真的是每一步都有接口可以重新实现。上线之后并没有预计的出现太多的问题，但是在中间做封装的时候有两个功能让读过的源码有了用武之地：</p>
<ul>
<li><p>一是UIL也是很厉害的，它实现了Picasso和Glide都没有做到的加载视频缩略图，只要传入视频路径，就能直接展示一张缩略图。读过Glide的源码之后，其实这个不算难事，Glide从源路径获取数据这部分是通过ModelLoader去做的，只要实现一个专门的ModelLoader，再结合SDK提供的ThumbnailUtil工具类，就可以获取到并加载视频缩略图了。</p>
</li>
<li><p>二是我们要做一个全局的视频加载库，可以实现从下载到播放的过程，与图片加载库没有本质区别，还少了一步内存缓存。这部分就要关心Glide最终加载的过程了，看源码我们能知道into（）方法里最终ImageView会被包装成一个Target来展示图片，那我们当然也可以重写Target来展示视频了，而且还充分利用了Glide的其他特性，比我们自己写一个视频加载框架要更省事也更强大。</p>
</li>
</ul>
<p>在进行框架调研时，主动通读源码的好处是显而易见的，因为在封装的时候会尽量避开各种坑，在遇到坑时也能够根据框架的设计特性和扩展性进行解决或者规避问题。</p>
<h2 id="为了学习而读源码"><a href="#为了学习而读源码" class="headerlink" title="为了学习而读源码"></a>为了学习而读源码</h2><p>以上两种情况都属于为了具体需求而做的工作，很大程度是为了解决具体问题。接下来这种情况就是个人提升的关键了。</p>
<p>首先说从不主动读源码的坏处：一是容易养成一切靠Google、Stackoverfolw和GitHub的习惯，只会复制粘贴和调试，自己无法独立产出。二是你所处的环境里最厉害的人就是你的上限了，因为他写的代码是你能看到的代码的上限。</p>
<p>优秀的框架基本都是大神或者优质团队的代码精华，敢做开源项目的一般都是对框架功能和代码质量有极高信心的人，所以找一些流行的框架，通读源码，学习其中的细节和设计模式，对自己的日常工作肯定是有很大好处的。读这些顶级程序员写的代码，无形中也提升了自己的上限。只能说看这些优秀源码越多，越知道自己不能只停留在使用的层面，要想更进一步，读源码算是个捷径。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>说了这么多，无论是出于以上三种的哪一种动机，其实都不重要。如果对编程有所追求，想在自己这个方向有所建树，阅读源码肯定是不可或缺的一步。很多人平时停留在会用即可，不去深挖，想跳槽时又只能在简历上写些熟悉某些库的使用，谈到实现细节一问三不知，最后又嫌人家要求太高。其实我们现在做开发都明白，库的封装性在越来越高，学习成本越来越低，一般的库只学基本使用，可能就是一个小时的事情，而对原理的掌握才是与别人区分开的标志。知其然且知其所以然，才是区分牛人和码农的标志。另外，很多人停留在会用的阶段也与需求难度和软件的受众数量有关，但是在一个成熟的、日活百万甚至千万级的APP里，面对千奇百怪的需求，只是会用这个库，恐怕只会让你掉进坑里再也出不来了。</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_posts-Tinker源码分析" class="article article-type-_posts" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/19/Tinker源码分析/" class="article-date">
  	<time datetime="2017-04-19T14:20:47.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/Tinker源码分析/">Tinker源码分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Tinker太复杂了，源码解析稍后再来。</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_posts-Picasso源码结构分析" class="article article-type-_posts" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/08/Picasso源码结构分析/" class="article-date">
  	<time datetime="2017-04-08T11:33:07.000Z" itemprop="datePublished">2017-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/08/Picasso源码结构分析/">Picasso源码结构分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>前一段时间复习了<code>Glide</code>的源码，而且这次做了文字整理，又被大神的思路震惊了一次。正好赶上清明假，就把用起来特别相似的，出自JakeWarton大神的<code>Picasso</code>的源码也分析一下，同时跟<code>Glide</code>也做个简单的比较。</p>
<p><code>Picasso</code>的官网在<a href="http://square.github.io/picasso/" target="_blank" rel="external">http://square.github.io/picasso/</a><br>用法跟<code>Glide</code>基本一致，就不用多废话介绍了，毕竟已经很有名了。这篇分析基于<code>Picasso 2.5.2</code>。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>还是按照规矩先上图：</p>
<p><img src="http://omy50xsvp.bkt.clouddn.com/17-4-4/32085605-file_1491296793698_a75d.jpg" alt=""></p>
<p>看起来有点绕，因为<code>Picasso</code>不像<code>Glide</code>那样类和接口特别多，而是用很少的类实现了强大的功能，那么也就不可避免的有的类承担了多种工作。接下来我们就来分析这些类的作用。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们还是从最基本的<code>Picasso.with(context).load(url).into(view)</code>来分析吧。首先看第一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"context == null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Picasso.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Builder(context).build();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>with(context)</code>方法本质上什么都没做，<code>Picasso</code>只支持一种上下文，它不管这是<code>ApplicationContext</code>还是<code>Activity</code>，然后返回了一个单例。那我们再看<code>load(url)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(@Nullable Uri uri)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, uri, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就引出我们的第二个角色了，<code>RequestCreator</code>,类如其名，这个类用来根据传入的参数构建一个请求，注意，它会持有<code>Picasso</code>单例的引用，<code>into(view)</code>方法当然也在里面了，继续看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Request.Builder data;</span><br><span class="line"></span><br><span class="line">RequestCreator(Picasso picasso, Uri uri, <span class="keyword">int</span> resourceId) &#123;</span><br><span class="line">  <span class="keyword">if</span> (picasso.shutdown) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Picasso instance already shut down. Cannot submit new requests."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.picasso = picasso;</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="keyword">new</span> Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target)</span> </span>&#123;</span><br><span class="line">  into(target, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target, Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> started = System.nanoTime();</span><br><span class="line">  checkMain();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!data.hasImage()) &#123;</span><br><span class="line">    picasso.cancelRequest(target);</span><br><span class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">      setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.hasSize()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with resize."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> width = target.getWidth();</span><br><span class="line">    <span class="keyword">int</span> height = target.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span> || target.isLayoutRequested()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data.resize(width, height);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Request request = createRequest(started);</span><br><span class="line">  String requestKey = createKey(request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">    Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">      picasso.cancelRequest(target);</span><br><span class="line">      setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">      <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">"from "</span> + MEMORY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.onSuccess();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">    setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Action action =</span><br><span class="line">      <span class="keyword">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</span><br><span class="line">          errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line"></span><br><span class="line">  picasso.enqueueAndSubmit(action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">createRequest</span><span class="params">(<span class="keyword">long</span> started)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> id = nextId.getAndIncrement();</span><br><span class="line"></span><br><span class="line">   Request request = data.build();</span><br><span class="line">   request.id = id;</span><br><span class="line">   request.started = started;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> loggingEnabled = picasso.loggingEnabled;</span><br><span class="line">   <span class="keyword">if</span> (loggingEnabled) &#123;</span><br><span class="line">     log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Request transformed = picasso.transformRequest(request);</span><br><span class="line">   <span class="keyword">if</span> (transformed != request) &#123;</span><br><span class="line">     <span class="comment">// If the request was changed, copy over the id and timestamp from the original.</span></span><br><span class="line">     transformed.id = id;</span><br><span class="line">     transformed.started = started;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (loggingEnabled) &#123;</span><br><span class="line">       log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), <span class="string">"into "</span> + transformed);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> transformed;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码就有干货了。在<code>into</code>方法里，我们能看到在一连串检查线程，获取尺寸等等一系列准备工作之后，<code>Request</code>终于出现了，它由内部的<code>Builder</code>构建出来（具体细节就不在这里分析了，与多数框架的<code>Request</code>没有大的区别，都只负责携带信息），然后它再加上一个外界传入的请求需要的各种各样的配置信息，就构成了干实事的<code>Action</code>。这个<code>Action</code>内部实现先不看，这时候刚才传入的<code>Picasso</code>对象起作用了，看<code>Picasso</code>里的<code>enqueueAndSubmit(action)</code>方法干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueAndSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">  Object target = action.getTarget();</span><br><span class="line">  <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</span><br><span class="line">    <span class="comment">// This will also check we are on the main thread.</span></span><br><span class="line">    cancelExistingRequest(target);</span><br><span class="line">    targetToAction.put(target, action);</span><br><span class="line">  &#125;</span><br><span class="line">  submit(action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">  dispatcher.dispatchSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又一个重要的角色出现了，<code>Dispatcher</code>。在很多框架里都有<code>Dispatcher</code>这个概念，比如赫赫有名的<code>Volley</code>。<code>Dispatcher</code>不用看，都知道是一个管理所有请求的调度器，顺着这个方法我们找到了<code>Dispatcher</code>中实际的实现类<code>performSubmit</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> ExecutorService service;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">    pausedActions.put(action.getTarget(), action);</span><br><span class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</span><br><span class="line">          <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BitmapHunter hunter = hunterMap.get(action.getKey());</span><br><span class="line">  <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hunter.attach(action);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (service.isShutdown()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class="string">"because shut down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</span><br><span class="line">  hunter.future = service.submit(hunter);</span><br><span class="line">  hunterMap.put(action.getKey(), hunter);</span><br><span class="line">  <span class="keyword">if</span> (dismissFailed) &#123;</span><br><span class="line">    failedActions.remove(action.getTarget());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">    log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> BitmapHunter <span class="title">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span><br><span class="line">    Action action)</span> </span>&#123;</span><br><span class="line">  Request request = action.getRequest();</span><br><span class="line">  List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Index-based loop to avoid allocating an iterator.</span></span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">    RequestHandler requestHandler = requestHandlers.get(i);</span><br><span class="line">    <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是<code>ExecutorService</code>,而且又一个关键角色也出现了–<code>BitmapHunter</code><em>大概这个类名也表明了<code>Picasso</code>只做纯图片加载的意图</em>。首先可以肯定的是<code>BitmapHunter</code>实现了<code>Runnable</code>接口，从代码里我们可以看到它携带者<code>Action</code>、<code>Cache</code>等一众小弟，注意，它这时候也持有<code>Picasso</code>和当前<code>Dispatcher</code>的实例，然后去工作线程干活去了。接下来当然是看<code>BitmapHunter</code>里的<code>run()</code>方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    updateThreadName(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = hunt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dispatcher.dispatchComplete(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NetworkRequestHandler.ResponseException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!NetworkPolicy.isOfflineOnly(e.networkPolicy) || e.code != <span class="number">504</span>) &#123;</span><br><span class="line">      exception = e;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    exception = e;</span><br><span class="line">    dispatcher.dispatchRetry(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">    StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">    stats.createSnapshot().dump(<span class="keyword">new</span> PrintWriter(writer));</span><br><span class="line">    exception = <span class="keyword">new</span> RuntimeException(writer.toString(), e);</span><br><span class="line">    dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    exception = e;</span><br><span class="line">    dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Bitmap <span class="title">hunt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">    bitmap = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stats.dispatchCacheHit();</span><br><span class="line">      loadedFrom = MEMORY;</span><br><span class="line">      <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_HUNTER, VERB_DECODED, data.logId(), <span class="string">"from cache"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  networkPolicy = retryCount == <span class="number">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">  RequestHandler.Result result = requestHandler.load(data, networkPolicy);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loadedFrom = result.getLoadedFrom();</span><br><span class="line">    exifOrientation = result.getExifOrientation();</span><br><span class="line">    bitmap = result.getBitmap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was no Bitmap then we need to decode it from the stream.</span></span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Source source = result.getSource();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        bitmap = decodeStream(source, data);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//noinspection ConstantConditions If bitmap is null then source is guranteed non-null.</span></span><br><span class="line">          source.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_HUNTER, VERB_DECODED, data.logId());</span><br><span class="line">    &#125;</span><br><span class="line">    stats.dispatchBitmapDecoded(bitmap);</span><br><span class="line">    <span class="keyword">if</span> (data.needsTransformation() || exifOrientation != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (DECODE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.needsMatrixTransform() || exifOrientation != <span class="number">0</span>) &#123;</span><br><span class="line">          bitmap = transformResult(data, bitmap, exifOrientation);</span><br><span class="line">          <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.hasCustomTransformations()) &#123;</span><br><span class="line">          bitmap = applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">          <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), <span class="string">"from custom transformations"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stats.dispatchBitmapTransformed(bitmap);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>run()</code>里面，其实就是把结果回调给持有的<code>Dispatcher</code>，让它对结果做处理。关键是<code>hunt()</code>，在这里，它走了从内存缓存取数据，未命中则构建<code>RequestHandler</code>从数据源取数据的过程，然后经过一系列处理之后，返回最终的<code>Bitmap</code>对象。<code>RequestHandler</code>的作用稍后讲。<code>BitmapHunter</code>名不虚传，这时候<code>Bitmap</code>已经拿到了，该把它又返回上层了。然后我们就能看到在<code>run()</code>方法里各种情况下执行的<code>Dispatcher</code>不同的回调方法。我们只看成功的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">    cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">  &#125;</span><br><span class="line">  hunterMap.remove(hunter.getKey());</span><br><span class="line">  batch(hunter);</span><br><span class="line">  <span class="keyword">if</span> (hunter.getPicasso().loggingEnabled) &#123;</span><br><span class="line">    log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), <span class="string">"for completion"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hunter.isCancelled()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  batch.add(hunter);</span><br><span class="line">  <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">    handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBatchComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(batch);</span><br><span class="line">  batch.clear();</span><br><span class="line">  mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</span><br><span class="line">  logBatch(copy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被处理完的<code>Bitmap</code>对应的<code>BitmapHunter</code>被一步步向上传递，然后通过一个<code>handlerThread</code>将结果又传回给了<code>Picasso</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">case</span> HUNTER_BATCH_COMPLETE: &#123;</span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</span><br><span class="line">        <span class="comment">//noinspection ForLoopReplaceableByForEach</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">          BitmapHunter hunter = batch.get(i);</span><br><span class="line">          hunter.picasso.complete(hunter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">        Action single = hunter.getAction();</span><br><span class="line">        List&lt;Action&gt; joined = hunter.getActions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hasMultiple = joined != <span class="keyword">null</span> &amp;&amp; !joined.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> shouldDeliver = single != <span class="keyword">null</span> || hasMultiple;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shouldDeliver) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Uri uri = hunter.getData().uri;</span><br><span class="line">        Exception exception = hunter.getException();</span><br><span class="line">        Bitmap result = hunter.getResult();</span><br><span class="line">        LoadedFrom from = hunter.getLoadedFrom();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="keyword">null</span>) &#123;</span><br><span class="line">          deliverAction(result, from, single, exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasMultiple) &#123;</span><br><span class="line">          <span class="comment">//noinspection ForLoopReplaceableByForEach</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = joined.size(); i &lt; n; i++) &#123;</span><br><span class="line">            Action join = joined.get(i);</span><br><span class="line">            deliverAction(result, from, join, exception);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span> &amp;&amp; exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">          listener.onImageLoadFailed(<span class="keyword">this</span>, uri, exception);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverAction</span><span class="params">(Bitmap result, LoadedFrom from, Action action, Exception e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.isCancelled()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!action.willReplay()) &#123;</span><br><span class="line">    targetToAction.remove(action.getTarget());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (from == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LoadedFrom cannot be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    action.complete(result, from);</span><br><span class="line">    <span class="keyword">if</span> (loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), <span class="string">"from "</span> + from);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    action.error(e);</span><br><span class="line">    <span class="keyword">if</span> (loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_MAIN, VERB_ERRORED, action.request.logId(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果又到了<code>Picasso</code>里面，在这里，它把最终结果传给<code>Action</code>，<code>Action</code>是一个抽象方法，我们看最典型的<code>ImageViewAction</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</span><br><span class="line">        String.format(<span class="string">"Attempted to complete action with no result!\n%s"</span>, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ImageView target = <span class="keyword">this</span>.target.get();</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Context context = picasso.context;</span><br><span class="line">  <span class="keyword">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</span><br><span class="line">  PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    callback.onSuccess();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么一个完整的加载过程在这里就结束了。</p>
<h2 id="与Glide的异同"><a href="#与Glide的异同" class="headerlink" title="与Glide的异同"></a>与<code>Glide</code>的异同</h2><ul>
<li><p>说实话我能想到的同也就是使用方法类似了，另外大的结构也有类似的地方，比如<code>Glide</code>的<code>ModelLoader</code>、<code>Engine</code>和<code>Target</code>分别对应<code>Picasso</code>的<code>RequestHandler</code>、<code>Dispatcher</code>和<code>Action</code>,但是如果从零设计一个图片框架的话，应该都会有这些部分。</p>
</li>
<li><p>不同的地方，其实就是设计思路的不同。<code>Glide</code>的功能强大，不仅可以加载一般的图片，也能加载gif、视频，因此具备极致的扩展性，几乎每个组件是一个接口可供外界重新实现，另外它宣传具有极致的滑动流畅性，因此在内存缓存上做了很大的文章，一个完整请求会有四级缓存，其中设计了<code>BitmapPool</code>这个神器来提升列表滑动的体验。</p>
</li>
<li><p>而<code>Picasso</code>，是一个纯粹的轻量级图片框架。它只能处理<code>Bitmap</code>，也只愿意处理它。在<code>Picasso</code>的issues里很多人都想要更多的功能，得到的答复都是<code>Picasso</code>目前的目标均已实现。它比<code>Glide</code>轻数倍，甚至没有分包，而且扩展性并不强，只能说在加载图片上有一定的可定制性。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Picasso</code>的源码很好读，没有<code>Glide</code>那么多绕来绕去的抽象方法和接口，<em>读完Glide再来读Picasso完全就是享受</em>，它比<code>Glide</code>更轻，能够满足绝大部分场景的图片加载，因此也是很成功的图片加载框架。<code>Picasso</code>的扩展性没那么强，另外它强依赖于<code>OkHttp</code>，甚至磁盘缓存都是通过<code>OkHttp</code>的磁盘缓存做的，可见<code>Square</code>对自己全家桶的自信程度。只能说这个库的目标就是<code>Square</code>全家桶的使用者，毕竟现在哪个新项目不会用<code>OkHttp</code>呢？</p>
<p>但是！再轻的库，麻烦还是分个包好不好···各种各样的类放在一个包里，强迫症有点受不了···</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_post-Glide源码分析-缓存" class="article article-type-_post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/19/Glide源码分析-缓存/" class="article-date">
  	<time datetime="2017-03-19T07:26:50.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/Glide源码分析-缓存/">Glide源码分析-缓存</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>每一个优秀的图片图片框架都会有完善的缓存管理机制，<code>Glide</code>当然不例外。这一部分就是分析它的缓存相关模块。流程图就不需要画了，缓存的本质无非就是<code>put</code>和<code>get</code>，而且<code>Glide</code>的所有缓存的实现都是<code>Lru</code>，与我们常见的<code>LruCache</code>并没有本质区别，所以我们只分析<code>Glide</code>的缓存思想和优化工作。</p>
<h3 id="相关类的介绍"><a href="#相关类的介绍" class="headerlink" title="相关类的介绍"></a>相关类的介绍</h3><p><code>Glide</code>的缓存分为两大部分，一类是常规的内存和磁盘缓存，另一类是<code>Glide</code>独有的<code>BitmapPool</code>缓存。</p>
<ul>
<li><code>MemoryCache</code>: 传统的内存缓存接口</li>
<li><code>activeResources</code>: 在我们之前分析<code>Engine</code>时提到过的一个弱引用为值得Map，作为第二层内存缓存</li>
<li><code>DishCache</code>: 传统的磁盘缓存接口</li>
<li><code>BitmapPool</code>: <code>Bitmap</code>池接口，用于避免反复创建相同尺寸和属性的<code>Bitmap</code>而消耗性能</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>Glide</code>的缓存机制有两类，我们先分析比较传统的一类，也就是大家都会用到的内存缓存和磁盘缓存。在我们之前分析过的<code>Engine</code>的<code>load()</code>方法代码里，我们能看到内存缓存的身影:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T, Z, R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(Key signature, <span class="keyword">int</span> width, <span class="keyword">int</span> height, DataFetcher&lt;T&gt; fetcher,</span><br><span class="line">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span><br><span class="line">        Priority priority, <span class="keyword">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cb.onResourceReady(cached);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cb.onResourceReady(active);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached.acquire();</span><br><span class="line">        activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EngineResource result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">        <span class="comment">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class="line">        result = (EngineResource) cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> EngineResource(cached, <span class="keyword">true</span> <span class="comment">/*isCacheable*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们由之前的分析可以知道，在真正发起一个<code>EngineRunnable</code>请求之前，会先从内存缓存和<code>activeResources</code>里尝试取数据，内存缓存其实不用多做分析，与我们平时用的没有本质区别。关键是<code>activeResources</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; active = <span class="keyword">null</span>;</span><br><span class="line">    WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class="line">    <span class="keyword">if</span> (activeRef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        active = activeRef.get();</span><br><span class="line">        <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">            active.acquire();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            activeResources.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached.acquire();</span><br><span class="line">        activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEngineJobComplete</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="comment">// A null resource indicates that the load failed, usually due to an exception.</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resource.setResourceListener(key, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resource.isCacheable()) &#123;</span><br><span class="line">            activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, resource, getReferenceQueue()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> should this check that the engine job is still current?</span></span><br><span class="line">    jobs.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>activeResources</code>是一个以弱引用<code>Resource</code>为值的Map，只要这次请求获取到数据时，它都会将结果缓存进去，作为第二级缓存备用。比一般内存缓存额外多一级缓存的意义在于，当内存不足时清理内存缓存中的资源时，不会对使用中的<code>Resource</code>造成影响。</p>
<p>而磁盘缓存我们在上一部分分析的时候已经分析过了，在一个<code>DecodeJob</code>中，会首先从磁盘缓存中获取数据；如果没有命中，则从数据源取到数据之后会写入磁盘缓存备用。<br>通过以上的逻辑，<code>Glide</code>就实现了一个传统的缓存结构。但是<code>Glide</code>之所以在推出的时候，宣传的是它在列表里表现的”丝般顺滑”,主要还是源于它的<code>BitmapPool</code>设计。我们首先看下<code>BitmapPool</code>的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruBitmapPool</span> <span class="keyword">implements</span> <span class="title">BitmapPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"LruBitmapPool"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LruPoolStrategy strategy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Bitmap.Config&gt; allowedConfigs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initialMaxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitmapTracker tracker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> misses;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> puts;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> evictions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exposed for testing only.</span></span><br><span class="line">    LruBitmapPool(<span class="keyword">int</span> maxSize, LruPoolStrategy strategy, Set&lt;Bitmap.Config&gt; allowedConfigs) &#123;</span><br><span class="line">        <span class="keyword">this</span>.initialMaxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        <span class="keyword">this</span>.allowedConfigs = allowedConfigs;</span><br><span class="line">        <span class="keyword">this</span>.tracker = <span class="keyword">new</span> NullBitmapTracker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Constructor for LruBitmapPool.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> maxSize The initial maximum size of the pool in bytes.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruBitmapPool</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Constructor for LruBitmapPool.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> maxSize The initial maximum size of the pool in bytes.</span><br><span class="line">     * <span class="doctag">@param</span> allowedConfigs A white listed set of &#123;<span class="doctag">@link</span> android.graphics.Bitmap.Config&#125; that are allowed to be put</span><br><span class="line">     *                       into the pool. Configs not in the allowed set will be rejected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruBitmapPool</span><span class="params">(<span class="keyword">int</span> maxSize, Set&lt;Bitmap.Config&gt; allowedConfigs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(maxSize, getDefaultStrategy(), allowedConfigs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSizeMultiplier</span><span class="params">(<span class="keyword">float</span> sizeMultiplier)</span> </span>&#123;</span><br><span class="line">        maxSize = Math.round(initialMaxSize * sizeMultiplier);</span><br><span class="line">        evict();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Bitmap must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bitmap.isMutable() || strategy.getSize(bitmap) &gt; maxSize || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                Log.v(TAG, <span class="string">"Reject bitmap from pool"</span></span><br><span class="line">                        + <span class="string">", bitmap: "</span> + strategy.logBitmap(bitmap)</span><br><span class="line">                        + <span class="string">", is mutable: "</span> + bitmap.isMutable()</span><br><span class="line">                        + <span class="string">", is allowed config: "</span> + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = strategy.getSize(bitmap);</span><br><span class="line">        strategy.put(bitmap);</span><br><span class="line">        tracker.add(bitmap);</span><br><span class="line"></span><br><span class="line">        puts++;</span><br><span class="line">        currentSize += size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Put bitmap in pool="</span> + strategy.logBitmap(bitmap));</span><br><span class="line">        &#125;</span><br><span class="line">        dump();</span><br><span class="line"></span><br><span class="line">        evict();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Bitmap <span class="title">get</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Bitmap.Config config)</span> </span>&#123;</span><br><span class="line">        Bitmap result = getDirty(width, height, config);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Bitmaps in the pool contain random data that in some cases must be cleared for an image to be rendered</span></span><br><span class="line">            <span class="comment">// correctly. we shouldn't force all consumers to independently erase the contents individually, so we do so</span></span><br><span class="line">            <span class="comment">// here. See issue #131.</span></span><br><span class="line">            result.eraseColor(Color.TRANSPARENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Bitmap <span class="title">getDirty</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Bitmap.Config config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Config will be null for non public config types, which can lead to transformations naively passing in</span></span><br><span class="line">        <span class="comment">// null as the requested config here. See issue #194.</span></span><br><span class="line">        <span class="keyword">final</span> Bitmap result = strategy.get(width, height, config != <span class="keyword">null</span> ? config : DEFAULT_CONFIG);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Missing bitmap="</span> + strategy.logBitmap(width, height, config));</span><br><span class="line">            &#125;</span><br><span class="line">            misses++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hits++;</span><br><span class="line">            currentSize -= strategy.getSize(result);</span><br><span class="line">            tracker.remove(result);</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">                result.setHasAlpha(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Get bitmap="</span> + strategy.logBitmap(width, height, config));</span><br><span class="line">        &#125;</span><br><span class="line">        dump();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"clearMemory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        trimToSize(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressLint</span>(<span class="string">"InlinedApi"</span>)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"trimMemory, level="</span> + level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) &#123;</span><br><span class="line">            clearMemory();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) &#123;</span><br><span class="line">            trimToSize(maxSize / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是<code>BitmapPool</code>的主要实现类<code>LruBitmapPool</code>关键的一部分代码。我们可以看到在<code>put()</code>方法里，并没有常见的<code>key</code>值，<code>key</code>是完全根据<code>Bitmap</code>的尺寸和属性生成的。在<code>get()</code>方法里，也是通过传入尺寸和属性获取对象的。其实不需要看<code>BitmapPool</code>是怎么使用的，光看这部分其实就可以知道它的设计思路了。在Andorid的<code>ListView</code>和<code>RecyclerView</code>中，如果item里有图片的话，快速滑动的过程中无法避免不断创建新的<code>Bitmap</code>对象供item使用，在<code>ListView</code>和<code>RecyclerView</code>中<code>View</code>是可复用的，<code>Bitmap</code>并不是，而在Android中<code>Bitmap</code>的创建是一件非常耗费自愿的事情，所有因此衍生出这个<code>BitmapPool</code>，当已经有尺寸和属性相同的<code>Bitmap</code>被创建出来后就不用再创建新的了，直接使用之前的就行。我们可以看某个地方使用<code>BitmapPool</code>的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CenterCrop</span> <span class="keyword">extends</span> <span class="title">BitmapTransformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CenterCrop</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CenterCrop</span><span class="params">(BitmapPool bitmapPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bitmapPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bitmap doesn't implement equals, so == and .equals are equivalent here.</span></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"PMD.CompareObjectsWithEquals"</span>)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bitmap toReuse = pool.get(outWidth, outHeight, toTransform.getConfig() != <span class="keyword">null</span></span><br><span class="line">                ? toTransform.getConfig() : Bitmap.Config.ARGB_8888);</span><br><span class="line">        Bitmap transformed = TransformationUtils.centerCrop(toReuse, toTransform, outWidth, outHeight);</span><br><span class="line">        <span class="keyword">if</span> (toReuse != <span class="keyword">null</span> &amp;&amp; toReuse != transformed &amp;&amp; !pool.put(toReuse)) &#123;</span><br><span class="line">            toReuse.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transformed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CenterCrop.com.bumptech.glide.load.resource.bitmap"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在用于生成<code>centerCrop</code>效果的<code>Transformation</code>里，我们能看到在<code>transform</code>方法里就传入了全局的<code>BitmapPool</code>，在构建目标的<code>Bitmap</code>时，会从<code>BitmapPool</code>中取对应的<code>Bitmap</code>以复用。这样就避免了每次都必须创建一个新的<code>Bitmap</code>进而消耗太多资源。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Glide</code>的缓存机制的优秀之处，一是<code>BitmapPool</code>机制，二是<code>activeResources</code>这个第二级缓存增加了内存缓存的命中率。<code>Glide</code>通过缓存机制达到了它所宣传的顺滑的特点。当然，<code>BitmapPool</code>肯定会占用部分内存，但是与提升体验相比瑕不掩瑜。如果某些低端机型出现内存不够的情况，可能需要手动监听内存使用情况并及时调用<code>Glide.get(context).clearMemory()</code>。</p>
<p>对<code>Glide</code>的源码分析基本就是这样，但是还是建议完整地阅读源码，因为分析只能了解<code>Glide</code>整体的结构，对debug有帮助，但是如果想完全发挥<code>Glide</code>的巨大潜能，还是应该阅读源码并结合官方文档，充分利用<code>ModelLoader</code>、<code>Transformation</code>以及<code>Target</code>这些可扩展的接口打造适合自己项目的框架。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_post-Glide源码分析-具体请求" class="article article-type-_post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/12/Glide源码分析-具体请求/" class="article-date">
  	<time datetime="2017-03-12T07:16:22.000Z" itemprop="datePublished">2017-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/12/Glide源码分析-具体请求/">Glide源码分析-具体请求</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>上一部分我们分析了<code>Glide</code>的生命周期管理，到这一步时<code>RequestManager</code>已经构建完成了，接下来就该依照外界传入的配置构建具体<code>Request</code>发出加载请求了，也就是终于到了真正干活的地方了。<code>Glide</code>的优秀之处（也是为什么有那么多代码）的原因就是在这个部分扩展性很强，你甚至可以把<code>Glide</code>完全改造，包括具体的网络请求、请求的数据类型、对最终数据的操作都可以重写，只让<code>Glide</code>处理线程调度和成名周期绑定，而不只是加载图片和gif。</p>
<h3 id="请求流程图"><a href="#请求流程图" class="headerlink" title="请求流程图"></a>请求流程图</h3><p><img src="http://p1.bpimg.com/567571/fa03572d345a0d09.jpg" alt="具体请求类图"></p>
<h3 id="相关类的介绍"><a href="#相关类的介绍" class="headerlink" title="相关类的介绍"></a>相关类的介绍</h3><ul>
<li><code>RequestManager</code>:用于接受外界传入的uri根据数据类型生成<code>GenericRequestBuilder</code></li>
<li><code>GenericRequestBuilder</code>:用于构建具体用于数据请求的<code>Request</code></li>
<li><code>Request</code>:携带一个具体请求相关的所有信息</li>
<li><code>Engine</code>:当<code>Request</code>被执行时，有<code>Engine</code>负责管理总体的数据请求流程</li>
<li><code>EngineRunnable</code>: 实现了<code>Runnable</code>，有这个类持有<code>EngineJob</code>和<code>DecodeJob</code>在子线程进行原始数据请求</li>
<li><code>EngineJob</code>: 负责开启数据请求及将结果通过<code>EngineJobListener</code>和<code>ResourceCallback</code>回调给<code>EngineJob</code>和具体的<code>Request</code></li>
<li><code>DecodeJob</code>: 真正执行数据请求的类，向外界暴露从缓存中请求和从数据源请求原始数据的方法</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>与之前一样，这个过程只看只看类的作用只能看个大概，还是需要搬出来源码解释问题。我们以<code>Glide.with(context).load(url).into(imageview)</code>为例，首先看<code>RequestManager</code>中的相关方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">load</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">fromString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> loadGeneric(String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">DrawableTypeRequest&lt;T&gt; <span class="title">loadGeneric</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//构建传入的数据类型对应的ModelLoader</span></span><br><span class="line">      ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);</span><br><span class="line">      ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =</span><br><span class="line">              Glide.buildFileDescriptorModelLoader(modelClass, context);</span><br><span class="line">      <span class="keyword">if</span> (modelClass != <span class="keyword">null</span> &amp;&amp; streamModelLoader == <span class="keyword">null</span> &amp;&amp; fileDescriptorModelLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown type "</span> + modelClass + <span class="string">". You must provide a Model of a type for"</span></span><br><span class="line">                  + <span class="string">" which there is a registered ModelLoader, if you are using a custom model, you must first call"</span></span><br><span class="line">                  + <span class="string">" Glide#register with a ModelLoaderFactory for your custom model class"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> optionsApplier.apply(</span><br><span class="line">              <span class="keyword">new</span> DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</span><br><span class="line">                      glide, requestTracker, lifecycle, optionsApplier));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分源码比较抽象，但是做的事情并不复杂，就是拿到传入的数据后，根据数据类型构建一个<code>ModelLoader</code>，这个<code>ModelLoader</code>的作用后面讲。然后再拿着这个<code>ModelLoader</code>构建一个<code>DrawableTypeRequest</code>，这个<code>DrawableTypeRequest</code>是<code>GenericRequestBuilder</code>的子类，然后看它的相关源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尴尬，好像是一个建造者模式，只是传入了数据，并没有进行操作，但是也可以知道，<code>Glide.with(context).load(url).into(imageview)</code>这个完整请求的最后一步，<code>into()</code>方法肯定也在这个类里面，那我们继续看相关源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null View"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isTransformationSet &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">                applyCenterCrop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                applyFitCenter();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//$CASES-OMITTED$</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y target)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null Target"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must first set a model (try #load())"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        previous.clear();</span><br><span class="line">        requestTracker.removeRequest(previous);</span><br><span class="line">        previous.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request = buildRequest(target);</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    lifecycle.addListener(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是<code>into(imageview)</code>这个方法，无视无用信息，关键代码只有最后一句，执行的是<code>into(target)</code>方法。然后我们继续看这个方法，这时候很明显了，在<code>into(target)</code>执行时，会构建一个<code>Request</code>，然后被执行<code>runRequest</code>。再看<code>runRequest</code>方法的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">        request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，本质上就是执行<code>Request</code>的<code>begin()</code>方法。<code>Request</code>是一个接口，我们看它的主要实现类<code>GenericRequest</code>的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onException(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">       logV(<span class="string">"Got onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">   width = Math.round(sizeMultiplier * width);</span><br><span class="line">   height = Math.round(sizeMultiplier * height);</span><br><span class="line"></span><br><span class="line">   ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class="line">   <span class="keyword">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dataFetcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">       onException(<span class="keyword">new</span> Exception(<span class="string">"Failed to load model: \'"</span> + model + <span class="string">"\'"</span>));</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class="line">   <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">       logV(<span class="string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">   &#125;</span><br><span class="line">   loadedFromMemoryCache = <span class="keyword">true</span>;</span><br><span class="line">   loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class="line">           priority, isMemoryCacheable, diskCacheStrategy, <span class="keyword">this</span>);</span><br><span class="line">   loadedFromMemoryCache = resource != <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">       logV(<span class="string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码如果想要完全搞清楚就必须翻源码了，基本流程是<code>begin()</code>方法被执行之后，会等待<code>onSizeReady</code>的回调执行，这句不用看也知道意思是要等<code>View</code>被绘制出来拿到具体尺寸之后，才真正发起请求，因为<code>Glide</code>在加载图片的时候都会根据<code>View</code>的尺寸对源数据进行压缩，缓存也只会缓存这种数据(任何图片库都一样，毕竟内存吃紧)。在<code>onSizeReady</code>毁掉中，我们只看关键代码，其实就是<code>Engine</code>的<code>load()</code>方法，我们再看这部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T, Z, R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(Key signature, <span class="keyword">int</span> width, <span class="keyword">int</span> height, DataFetcher&lt;T&gt; fetcher,</span><br><span class="line">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span><br><span class="line">        Priority priority, <span class="keyword">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String id = fetcher.getId();</span><br><span class="line">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class="line">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class="line">            transcoder, loadProvider.getSourceEncoder());</span><br><span class="line">    <span class="comment">//从内存缓存中取数据</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(cached);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从activeResources中取数据</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(active);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存缓存没有命中，发起一个EngineRunnable，请求源数据</span></span><br><span class="line">    EngineJob current = jobs.get(key);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        current.addCallback(cb);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class="line">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class="keyword">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class="line">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class="line">    EngineRunnable runnable = <span class="keyword">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    engineJob.start(runnable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较长，但是只看方法名的话也完全可以理解，先从内存缓存中取数据，没有命中就从activeResources中取，还没有命中就发起一个<code>EngineRunnable</code>请求源数据，<code>EngineRunnable</code>会持有一个<code>EngineJob</code>和一个<code>DecodeJob</code>，我们依次来看它们的作用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EngineJob.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService diskCacheService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService sourceService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(EngineRunnable engineRunnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.engineRunnable = engineRunnable;</span><br><span class="line">    future = diskCacheService.submit(engineRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitForSource</span><span class="params">(EngineRunnable runnable)</span> </span>&#123;</span><br><span class="line">    future = sourceService.submit(runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EngineRunnable.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EngineRunnableManager manager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        stage = Stage.SOURCE;</span><br><span class="line">        manager.submitForSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        manager.onException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Exception exception = <span class="keyword">null</span>;</span><br><span class="line">    Resource&lt;?&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resource = decode();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Exception decoding"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resource.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onLoadFailed(exception);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onLoadComplete(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴代码的时候才发现这两部分必须一起分析···先看<code>EngineJob</code>，它内部有两个<code>ExecutorService</code>，很明显一个是用于请求磁盘数据，另一个用于请求源数据。<code>EngineJob</code>实现了<code>EngineRunnableManager</code>这个接口，它只是用来管理这两个线程池的相关操作，同时通过持有的<code>ResourceCallback</code>和<code>EngineJobListener</code>将结果回调给<code>Request</code>和<code>Engine</code>，线程具体的<code>run()</code>方法在我们上面贴出的<code>EngineRunnable</code>里面，然后我们再看这部分代码，本质上就是通过<code>decode()</code>方法进行数据请求，如果属于请求磁盘数据且失败了，那么就去请求源数据，最终将结果回调给<code>EngineJob</code>。那么关键就是这个<code>decode()</code>方法了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decode() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromCache();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decodeFromCache() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Resource&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = decodeJob.decodeResultFromCache();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"Exception decoding result from cache: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = decodeJob.decodeSourceFromCache();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decodeFromSource() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> decodeJob.decodeFromSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码只看方法名也很清晰，就是通过持有的<code>DecodeJob</code>分别从缓存（磁盘缓存）和数据源去取数据，然后就引出了真正干活的<code>DecodeJob</code>了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//因为Glide磁盘缓存的策略中，可以选择缓存根据View尺寸压缩过后的文件。因此取缓存的第一步就是根据尺寸去取对应的缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeResultFromCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!diskCacheStrategy.cacheResult()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = loadFromCache(resultKey);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Decoded transformed from cache"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transcoded transformed from cache"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据缓存策略当ResultCache没有命中时就从磁盘缓存中取源数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeSourceFromCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Decoded source from cache"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取磁盘缓存的具体代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">loadFromCache</span><span class="params">(Key key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File cacheFile = diskCacheProvider.getDiskCache().get(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource&lt;T&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            diskCacheProvider.getDiskCache().delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取缓存失败，就去取源数据（从网络或是从本地文件路径）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeFromSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取源数据的具体过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">decodeSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">        <span class="keyword">final</span> A data = fetcher.loadData(priority);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Fetched data"</span>, startTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        decoded = decodeFromSourceData(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对取到的源数据进行解码操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">decodeFromSourceData</span><span class="params">(A data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resource&lt;T&gt; decoded;</span><br><span class="line">    <span class="keyword">if</span> (diskCacheStrategy.cacheSource()) &#123;</span><br><span class="line">        decoded = cacheAndDecodeSourceData(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">        decoded = loadProvider.getSourceDecoder().decode(data, width, height);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Decoded from source"</span>, startTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对取到的数据进行transform转换，写入磁盘缓存以及转码操作，获取最终target需要的数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Z&gt; <span class="title">transformEncodeAndTranscode</span><span class="params">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transformed resource from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeTransformedToCache(transformed);</span><br><span class="line"></span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transcoded transformed from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写缓存</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeTransformedToCache</span><span class="params">(Resource&lt;T&gt; transformed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transformed == <span class="keyword">null</span> || !diskCacheStrategy.cacheResult()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    SourceWriter&lt;Resource&lt;T&gt;&gt; writer = <span class="keyword">new</span> SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);</span><br><span class="line">    diskCacheProvider.getDiskCache().put(resultKey, writer);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Wrote transformed from source to cache"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码比较多，但是也基本就是取源数据的全部了。那么以一个网络请求数据源为例，这部分代码在哪里呢？就在<code>decodeSource()</code>里的<code>final A data = fetcher.loadData(priority);</code>这一句了，这个<code>DataFetcher</code>的所有实现类，就是从所有路径取请求源数据的实现了，我们以<code>OkHttp</code>对应的<code>OkHttpSteamFetcher</code>为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">loadData</span><span class="params">(Priority priority)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(url.toStringUrl());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : url.getHeaders().entrySet()) &#123;</span><br><span class="line">        String key = headerEntry.getKey();</span><br><span class="line">        requestBuilder.addHeader(key, headerEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    Request request = requestBuilder.build();</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    call = client.newCall(request);</span><br><span class="line">    response = call.execute();</span><br><span class="line">    responseBody = response.body();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Request failed with code: "</span> + response.code());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> contentLength = responseBody.contentLength();</span><br><span class="line">    stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用过<code>OkHttp</code>的同学都知道，这是<code>OkHttp</code>最基本的一个请求，通过这个请求，我们也通过传入的路径拿到了我们需要的数据流。到这时候，一个完整的请求就基本结束了。</p>
<p>不过还没完，因为数据拿到了，也处理完了，还没显示在<code>View</code>上，这时候就要回头看<code>Request</code>拿到的请求结果的回调里做了什么了，还是以实现类<code>GenericRequest</code>为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, R result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We must call isFirstReadyResource before setting status.</span></span><br><span class="line">    <span class="keyword">boolean</span> isFirstResource = isFirstReadyResource();</span><br><span class="line">    status = Status.COMPLETE;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestListener == <span class="keyword">null</span> || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,</span><br><span class="line">            isFirstResource)) &#123;</span><br><span class="line">        GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</span><br><span class="line">        target.onResourceReady(result, animation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(<span class="string">"Resource ready in "</span> + LogTime.getElapsedMillis(startTime) + <span class="string">" size: "</span></span><br><span class="line">                + (resource.getSize() * TO_MEGABYTE) + <span class="string">" fromCache: "</span> + loadedFromMemoryCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与我们预期的一致，请求结果被传递给<code>Request</code>对应的<code>target</code>的<code>onResourceReady</code>方法，在这个方法里完成了最终数据与View的绑定工作。到这时候，一个完整的图片加载过程就完成了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然，我们这一篇的分析真是跟着源码把数据请求的过程走了一遍，其中还有许多有意思的设计并没有设计。比如在<code>Target</code>的实现类<code>ViewTarget</code>中，会通过<code>view.setTag()</code>方法实现与<code>Request</code>的绑定，避免了同一个View的重复请求；通过抽象出一个<code>ModelLoader</code>和<code>DataFetcher</code>使使用者能够任意自定义底层数据请求的方式；通过抽象出<code>Transformation</code>使使用者能够在拿到最终数据之前进行自定义的处理。个人认为<code>Glide</code>优于<code>Picasso</code>的地方也在这里，就是极致的可扩展性。这部分原理靠文字是无法完全描述清楚的，还是需要从源码中寻找答案。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_post-Glide源码分析-生命周期管理" class="article article-type-_post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/05/Glide源码分析-生命周期管理/" class="article-date">
  	<time datetime="2017-03-05T12:00:41.000Z" itemprop="datePublished">2017-03-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/05/Glide源码分析-生命周期管理/">Glide源码分析-生命周期管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>Glide</code>与<code>Picasso</code>有着基本一致的使用方法，最基本的使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Glide.with(Context/Activity/Fragment).load(url).into(view);</span><br><span class="line"></span><br><span class="line">Picasso.with(Context).load(url).into(view);</span><br></pre></td></tr></table></figure>
<p>但是我们从代码中能看到，<code>Glide</code>比较特殊的地方时可以传入<code>Context</code>、<code>Activity</code>、<code>Fragment</code>三种不同的对象作为上下文，这也是<code>Glide</code>第一个比较突出的特点，就是严格使用的话，加载图片的过程会绑定对应页面的生命周期，尽可能地提升加载效率。</p>
<h3 id="生命周期绑定基本流程"><a href="#生命周期绑定基本流程" class="headerlink" title="生命周期绑定基本流程"></a>生命周期绑定基本流程</h3><p><img src="http://i1.piimg.com/567571/91a11d998864fea7.jpg" alt="生命周期绑定类设计图"></p>
<h3 id="相关类的介绍"><a href="#相关类的介绍" class="headerlink" title="相关类的介绍"></a>相关类的介绍</h3><ul>
<li><code>Glide</code>:总入口类，调用<code>with(Context/Activity/Fragment)</code>方法获取对应的<code>RequestManager</code></li>
<li><code>RequestManagerRetriever</code>:单例，根据<code>Glide.with()</code>方法传入的上下文构建<code>RequestManager</code>和对应的<code>RequestManagerFragment</code>并进行生命周期的绑定</li>
<li><code>RequestManagerFragment</code>:一个无页面的<code>Fragment</code>，与<code>Glide</code>传入的<code>Activity</code>或者<code>Fragment</code>通过<code>FragmentManager</code>完成与加载请求生命周期的绑定，同时持有对应所有上下文的<code>RequestManager</code>，当生命周期改变时时回调对应的生命周期方法</li>
<li><code>LifecycleListener</code>:生命周期回调接口，当对应的生命周期发生变化时收到通知</li>
<li><code>Lifecycle</code>:生命周期接口，所有类型的<code>RequestManagerFragment</code>都持有该接口的实现类<code>ActivityFragmentLifecycle</code>，<code>RequestManagerFragment</code>的生命周期发生变化时回调对应的方法</li>
<li><code>RequestManager</code>:实现了<code>LifecycleListener</code>接口，收到生命周期变化回调时调用持有的<code>Ruquest</code>的对应方法</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>只分析类的作用是不够的，不看代码根本解释不清楚。然后我们就以一个基本的<code>Glide</code>请求为例，看看在构建<code>Request</code>之前都发生了什么。<br>首先是<code>Glide.with()</code>方法，以<code>Glide.with(fragment)</code>为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    <span class="keyword">return</span> retriever.get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只看到是生成一个<code>RequestManagerRetriever</code>对象，然后调用对应的<code>get(fragment)</code>方法，那么我们再看这部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestManagerRetriever INSTANCE = <span class="keyword">new</span> RequestManagerRetriever();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (fragment.getActivity() == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a fragment before it is attached"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">         <span class="keyword">return</span> get(fragment.getActivity().getApplicationContext());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">         <span class="keyword">return</span> supportFragmentGet(fragment.getActivity(), fm);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>get()</code>方法很简单，就是一个单例模式。然后是<code>get(fragment)</code>方法，我们只看<code>fragment</code>可用的情况，这时候首先拿到那个<code>fragment</code>对应的<code>FragmentManager</code>，然后再返回<code>supportFragmentGet</code>方法，那么再看这部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">RequestManager <span class="title">supportFragmentGet</span><span class="params">(Context context, FragmentManager fm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前请求上下文对应FragmentManager内部用于绑定生命周期的RequestManagerFragment</span></span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">    <span class="comment">//获取RequestManagerFragment内部绑定的RequestManager</span></span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果为空，则new一个RequestManager，并完成生命周期回调方法的互相绑定</span></span><br><span class="line">        requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String FRAGMENT_TAG = <span class="string">"com.bumptech.glide.manager"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以FragmentManager为key，RequestManagerFragment为value缓存用以绑定寿命周期的RequestManagerFragment，严格说这不是一个缓存，只是用来暂时保存已生成的还未被使用的RequestManagerFragment</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;FragmentManager, SupportRequestManagerFragment&gt; pendingSupportRequestManagerFragments =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;FragmentManager, SupportRequestManagerFragment&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(<span class="keyword">final</span> FragmentManager fm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先从FragmentManager根据TAG获取RequestManagerFragment</span></span><br><span class="line">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为空，再从pending缓存里获取</span></span><br><span class="line">        current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果为空，则生成一个新的RequestManagerFragment并add到对应的FragmentManager里</span></span><br><span class="line">            current = <span class="keyword">new</span> SupportRequestManagerFragment();</span><br><span class="line">            pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当RequestManagerFragment被成功add之后从pending缓存中remove掉</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">true</span>;</span><br><span class="line">    Object removed = <span class="keyword">null</span>;</span><br><span class="line">    Object key = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> ID_REMOVE_FRAGMENT_MANAGER:</span><br><span class="line">            android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;</span><br><span class="line">            key = fm;</span><br><span class="line">            removed = pendingRequestManagerFragments.remove(fm);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:</span><br><span class="line">            FragmentManager supportFm = (FragmentManager) message.obj;</span><br><span class="line">            key = supportFm;</span><br><span class="line">            removed = pendingSupportRequestManagerFragments.remove(supportFm);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            handled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handled &amp;&amp; removed == <span class="keyword">null</span> &amp;&amp; Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Failed to remove expected request manager fragment, manager: "</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分源码比较长，结合注释看容易理清楚。本质上就是根据传入的上下文对应的<code>FragmentManager</code>生成对应的<code>RequestManager</code>和<code>RequestManagerFragment</code>并完成互相绑定的过程，那么接下来就看生命周期绑定的过程，也是核心部分，首先看<code>RequestManagerFragment</code>的相关部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportRequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RequestManager requestManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActivityFragmentLifecycle lifecycle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ActivityFragmentLifecycle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For testing only.</span></span><br><span class="line">    <span class="annotation">@SuppressLint</span>(<span class="string">"ValidFragment"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">(ActivityFragmentLifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestManager</span><span class="params">(RequestManager requestManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestManager = requestManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ActivityFragmentLifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">getRequestManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycle.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        lifecycle.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        lifecycle.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLowMemory();</span><br><span class="line">        <span class="comment">// If an activity is re-created, onLowMemory may be called before a manager is ever set.</span></span><br><span class="line">        <span class="comment">// See #329.</span></span><br><span class="line">        <span class="keyword">if</span> (requestManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestManager.onLowMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分源码删掉了不相关的代码，只看生命周期相关的方法。所以很明白，这个<code>RequestManagerFragment</code>继承自系统的<code>Fragment</code>，并持有对应的<code>RequestManager</code>和<code>ActivityFragmentLifecycle</code>，当生命周期发生变化时会调用这两个对象对应的方法。然后我们再看<code>ActivityFragmentLifecycle</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityFragmentLifecycle</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;LifecycleListener&gt; lifecycleListeners =</span><br><span class="line">            Collections.newSetFromMap(<span class="keyword">new</span> WeakHashMap&lt;LifecycleListener, Boolean&gt;());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStarted;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDestroyed;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">        lifecycleListeners.add(listener);</span><br><span class="line">        <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">            listener.onDestroy();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStarted) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listener.onStop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStarted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">            lifecycleListener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">            lifecycleListener.onStop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDestroyed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">            lifecycleListener.onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也很简单，<code>ActivityFragmentLifecycle</code>实现了<code>Lifecycle</code>接口，持有一群（手动斜眼）<code>lifecycleListener</code>，当它的生命周期方法被调用时，也会调用所有<code>lifecycleListener</code>对应的方法。那么是谁把这些<code>lifecycleListener</code>给add进来，谁实现了这个接口，最终在收到生命周期变化的通知时做出处理呢？答案就在<code>RequestManager</code>里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  RequestManager(Context context, <span class="keyword">final</span> Lifecycle lifecycle, RequestManagerTreeNode treeNode,</span><br><span class="line">        RequestTracker requestTracker, ConnectivityMonitorFactory factory) &#123;</span><br><span class="line">    <span class="keyword">this</span>.context = context.getApplicationContext();</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    <span class="keyword">this</span>.treeNode = treeNode;</span><br><span class="line">    <span class="keyword">this</span>.requestTracker = requestTracker;</span><br><span class="line">    <span class="keyword">this</span>.glide = Glide.get(context);</span><br><span class="line">    <span class="keyword">this</span>.optionsApplier = <span class="keyword">new</span> OptionsApplier();</span><br><span class="line"></span><br><span class="line">    ConnectivityMonitor connectivityMonitor = factory.build(context,</span><br><span class="line">            <span class="keyword">new</span> RequestManagerConnectivityListener(requestTracker));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're the application level request manager, we may be created on a background thread. In that case we</span></span><br><span class="line">    <span class="comment">// cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span></span><br><span class="line">    <span class="comment">// ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lifecycle.addListener(RequestManager.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addListener(connectivityMonitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚才在<code>RequestManagerRetriever</code>的源码里我们知道了，在生成<code>RequestManager</code>时它会持有对应<code>RequestManagerFragment</code>内部的<code>Lifecycle</code>，当它的构造方法被调用时，同时会把自己给add进去，这时候生命周期已经完全绑定，<code>RequestManager</code>已经可以拿到对应所有请求的生命周期回调。细心的同学会发现还会add一个<code>ConnectivityMonitor</code>，这个就属于响应网络变化的优化工作了，有兴趣的同学可以看相关源码。然后我们再看回调方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    resumeRequests();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pauseRequests();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    requestTracker.clearRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码很容易明白了，就是在页面发生变化时，请求也随之响应，达到效率最大化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Ok，关于<code>Glide</code>请求的生命周期管理就基本分析完毕，<code>Glide</code>看起来跟<code>Picasso</code>用法基本一致，设计也类似，但是多出那么多方法并不凭空来的，单只是用一个不可见的<code>Fragment</code>实现了对一个上下文的<code>Activity</code>和<code>Fragment</code>生命周期的监控，这部分的实现就非常巧妙。下一部分，我们继续分析 <code>Glide</code>构建<code>Request</code>完成后，接下来具体请求的过程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_post-Glide源码分析-概述" class="article article-type-_post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/04/Glide源码分析-概述/" class="article-date">
  	<time datetime="2017-03-04T08:12:19.000Z" itemprop="datePublished">2017-03-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/04/Glide源码分析-概述/">Glide源码分析-概述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>  项目地址：<a href="https://github.com/bumptech/glide" target="_blank" rel="external">https://github.com/bumptech/glide</a><br>  基于Glide当前的稳定版本3.7.0</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p><img src="http://i1.piimg.com/567571/8abbb8f9c56f6862.jpg" alt="glide_process"></p>
<p>大的流程与其他的图片加载库没有本质区别，都是构建一个图片加载请求，然后通过<strong>Engine</strong>先从内存缓存中获取数据，如果命中缓存则直接回调主线程并对View层进行对应处理；如果未命中缓存，则调起一个<strong>DecodeJob</strong>请求原始数据，先请求磁盘缓存，未命中则进行网络请求，最终将结果回调主线程。</p>
<h3 id="类设计图"><a href="#类设计图" class="headerlink" title="类设计图"></a>类设计图</h3><p><img src="http://i1.piimg.com/567571/787776846350f1b3.jpg" alt="glide_class"></p>
<h2 id="主要组件的概念"><a href="#主要组件的概念" class="headerlink" title="主要组件的概念"></a>主要组件的概念</h2><h3 id="Glide-入口类"><a href="#Glide-入口类" class="headerlink" title="Glide 入口类"></a><code>Glide</code> 入口类</h3><h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a><code>Glide</code></h4><ul>
<li>向外暴露单例静态接口，通过传入的<code>Context</code>构建RequestManager</li>
<li>持有一些内存变量BitmapPool，MemoryCache，便于外界调用清理缓存</li>
<li>同时在构造方法里完成<code>GenericLoaderFactory</code>、<code>TranscoderRegisty</code>和<code>DataLoaderRegisty</code>对多种数据和资源类型的注册（这几个类的作用后面分析）</li>
</ul>
<h4 id="GlideBuilder"><a href="#GlideBuilder" class="headerlink" title="GlideBuilder"></a><code>GlideBuilder</code></h4><ul>
<li>构建<code>Glide</code>对象，配置默认的缓存策略和图片解码格式</li>
</ul>
<h3 id="RequestManager-请求管理类"><a href="#RequestManager-请求管理类" class="headerlink" title="RequestManager 请求管理类"></a><code>RequestManager</code> 请求管理类</h3><h4 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a><code>RequestManager</code></h4><ul>
<li>通过<code>load</code>系列方法，构建具体的请求</li>
<li>通过持有的<code>RequestTracker</code>对象管理当前<code>RequestManager</code>下所有请求的生命周期</li>
</ul>
<h4 id="RequestTracker"><a href="#RequestTracker" class="headerlink" title="RequestTracker"></a><code>RequestTracker</code></h4><ul>
<li>对具体请求的行为进行管理</li>
</ul>
<h4 id="RequestManagerRetriever"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a><code>RequestManagerRetriever</code></h4><ul>
<li>单例，通过传入的<code>Context</code>或<code>Fragment</code>获取对应的<code>RequestManager</code></li>
</ul>
<h3 id="Request-请求类"><a href="#Request-请求类" class="headerlink" title="Request 请求类"></a><code>Request</code> 请求类</h3><ul>
<li>持有一个具体请求的所有信息，包括所有主动行为和状态的回调，通过<code>Engine</code>进行具体的数据请求，同时将回调结果通知<code>Target</code></li>
</ul>
<h3 id="Engine-引擎类"><a href="#Engine-引擎类" class="headerlink" title="Engine 引擎类"></a><code>Engine</code> 引擎类</h3><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a><code>Engine</code></h4><ul>
<li>请求数据并拿到回调结果</li>
<li>请求数据分为三步：先请求内存缓存<code>MemoryCache</code>，未命中则继续请求<code>activeResources</code>（具体会在缓存部分分析），仍然未命中则会调起一个<code>EngineRunnable</code>，开启一个线程进行具体请求</li>
</ul>
<h4 id="EngineRunnable"><a href="#EngineRunnable" class="headerlink" title="EngineRunnable"></a><code>EngineRunnable</code></h4><ul>
<li>实现了<code>Runnable</code>接口，用<code>DecodeJob</code>进行数据请求并将回调传递给<code>EngineJob</code></li>
</ul>
<h4 id="EngineJob"><a href="#EngineJob" class="headerlink" title="EngineJob"></a><code>EngineJob</code></h4><ul>
<li>管理对应<code>Engine</code>所有请求的<code>ResourceCallback</code></li>
</ul>
<h3 id="DecodeJob-原始对象处理类"><a href="#DecodeJob-原始对象处理类" class="headerlink" title="DecodeJob 原始对象处理类"></a><code>DecodeJob</code> 原始对象处理类</h3><h4 id="DecodeJob"><a href="#DecodeJob" class="headerlink" title="DecodeJob"></a><code>DecodeJob</code></h4><ul>
<li>进行具体取数据和数据转换的操作，包括从磁盘缓存和通过网络请求拿到原始数据，并将原始数据通过<code>ResourceDecoder</code>、<code>Transformation</code>和<code>ResourceTranscoder</code>转换成最终<code>Target</code>需要的数据类型</li>
<li>在通过网络请求拿到数据后也进行了写入磁盘缓存的操作</li>
</ul>
<h3 id="Cache缓存部分"><a href="#Cache缓存部分" class="headerlink" title="Cache缓存部分"></a><code>Cache</code>缓存部分</h3><h4 id="MemoryCache内存缓存接口"><a href="#MemoryCache内存缓存接口" class="headerlink" title="MemoryCache内存缓存接口"></a><code>MemoryCache</code>内存缓存接口</h4><ul>
<li>资源被释放时写入，在<code>Engine</code>类里从内存中获取数据时查询</li>
</ul>
<h4 id="DishCache磁盘缓存接口"><a href="#DishCache磁盘缓存接口" class="headerlink" title="DishCache磁盘缓存接口"></a><code>DishCache</code>磁盘缓存接口</h4><ul>
<li><code>DecodeJob</code>从磁盘中获取数据时查询，请求网络拿到原始数据时写入</li>
</ul>
<h4 id="BitmapPool接口"><a href="#BitmapPool接口" class="headerlink" title="BitmapPool接口"></a><code>BitmapPool</code>接口</h4><ul>
<li>设计思路是根据尺寸和属性缓存理论上会被重复使用的<code>Bitmap</code>对象，在有新的加载过程要用到同样的<code>Bitmap</code>时避免重复创建<code>Bitmap</code>,在<code>RecyclerView</code>这种会有大量可复用的相同尺寸和属性<code>Bitmap</code>的场景下效果明显</li>
<li>在<code>Transformation</code>中构建Bitmap时查询，在任意位置的<code>Bitmap</code>对象准备被释放时缓存</li>
</ul>
<h4 id="Engine中的activeResources"><a href="#Engine中的activeResources" class="headerlink" title="Engine中的activeResources"></a><code>Engine</code>中的<code>activeResources</code></h4><ul>
<li>这是一个弱引用的内存缓存，当<code>MemoryCache</code>中的缓存因为某些情况被remove掉时，会再在这个内存缓存里查询到，不会对使用中的Bitmap造成影响</li>
</ul>
<h3 id="可扩展接口"><a href="#可扩展接口" class="headerlink" title="可扩展接口"></a>可扩展接口</h3><h3 id="ModelLoader和对应的DataFetcher"><a href="#ModelLoader和对应的DataFetcher" class="headerlink" title="ModelLoader和对应的DataFetcher"></a><code>ModelLoader</code>和对应的<code>DataFetcher</code></h3><ul>
<li>可以配置自己的网络请求和数据类型</li>
</ul>
<h3 id="Transformation接口"><a href="#Transformation接口" class="headerlink" title="Transformation接口"></a><code>Transformation</code>接口</h3><ul>
<li>可以配置自己的<code>Bitmap</code>或者其他类型数据的处理方案，默认的<code>centerCrop()</code>和<code>fitCenter</code>方法都是实现了具体的<code>Transformation</code>接口</li>
</ul>
<h3 id="Target接口"><a href="#Target接口" class="headerlink" title="Target接口"></a><code>Target</code>接口</h3><ul>
<li>可以配置更复杂的View或其他业务层组件，<code>Glide</code>负责管理请求、缓存和数据转换。</li>
</ul>
<p><code>Glide</code>主要的类和接口基本就是这些，通过这些接口的关系我们已经基本能知道<code>Glide</code>进行一次完成的图片数据请求以及加载到View的过程了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="_posts-OkHttp源码结构分析" class="article article-type-_posts" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/10/OkHttp源码结构分析/" class="article-date">
  	<time datetime="2016-08-10T14:40:26.000Z" itemprop="datePublished">2016-08-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/OkHttp源码结构分析/">OkHttp源码结构分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>之前一篇简单介绍了<code>OkHttp</code>的概况和使用方式，以及如何与<code>Volley</code>一起使用，知其然也要知其所以然，这一篇大概介绍下这个网络框架的源码结构。基于<code>OkHttp 3.5.0</code></p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p><img src="http://omy50xsvp.bkt.clouddn.com/17-4-2/59741282-file_1491117652168_449f.png" alt="OkHttp源码结构图"></p>
<p>这个框架作为Android开发者应该是很熟悉的。入口的构建是建造者模式，在请求的时候手动构建一个<code>Request</code>，通过<code>OkHttpClient</code>的<code>newCall()</code>方法发起请求，获取<code>Response</code>，也就是请求最终的结果。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><h4 id="OkHttpClient-Bulider"><a href="#OkHttpClient-Bulider" class="headerlink" title="OkHttpClient.Bulider"></a><code>OkHttpClient.Bulider</code></h4><ul>
<li>负责构建<code>OkHttpClient</code>,Square官方的建议是全局共用一个<code>OkHttpClient</code>,实际上<code>OkHttpClient</code>虽然有public的狗仔方法，内部也是传入一个默认的Builder.</li>
</ul>
<h4 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a><code>OkHttpClient</code></h4><ul>
<li>处理配置这个client的参数，核心方法其实就一个：  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a><code>Request</code></h4><ul>
<li>这个类只用来存储请求的数据，不做实际的事情，具体请求的发起由下一个<code>RealCall</code>来做</li>
</ul>
<h4 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a><code>RealCall</code></h4><ul>
<li><code>RealCall</code>实现了<code>Call</code>接口，关于这个接口的作用，注释已经说清楚了,<code>RealCall</code>是唯一的实现，也就是<code>OkHttp</code>实际用来请求的类</li>
</ul>
<blockquote>
<p>A call is a request that has been prepared for execution. A call can be canceled. As this object<br>represents a single request/response pair (stream), it cannot be executed twice.</p>
</blockquote>
<ul>
<li>那么怎么干活呢？<code>Call</code>这个接口有两个关键的实现方法，<code>execute()</code>和<code>enqueue()</code>，方法名意思已经很明确了，一个同步一个异步，我们只需要看这两个方法的实现就可以了：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    Response result = getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">  AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">    <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> originalRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">        <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">        Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步方法很直接，通过<code>getResponseWithInterceptorChain()</code>直接取<code>Response</code>，异步方法则间接一点，包装一个<code>Runnable</code>扔给线程池，本质上最终使用的也是<code>getResponseWithInterceptorChain()</code>。然后我们就要看这个方法是何方神圣了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉<code>OkHttp</code>的同学都知道<code>OkHttp</code>有一个很厉害的东西，叫<code>Interceptor</code>，只要实现了这个接口，就可以在一个请求的<code>Request</code>和<code>Response</code>之间做很多文章，比如写个<code>LogInterceptor</code>打印请求的各种信息，实现也特别优雅，但是看了源码才知道，<code>Interceptor</code>贯穿了请求的全部，无论是重试机制、缓存还是具体请求，实际上都是通过<code>Interceptor</code>来做的。那么接下来就分析源码中用到的这些<code>Interceptor</code>.</p>
<h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a><code>RetryAndFollowUpInterceptor</code></h4><ul>
<li>负责重试和重定向</li>
</ul>
<h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a><code>BridgeInterceptor</code></h4><ul>
<li>负责把请求转换为发送给服务器的请求，把服务器返回的结果包装成我们接收到的<code>Response</code></li>
</ul>
<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a><code>CacheInterceptor</code></h4><ul>
<li>缓存命中时则直接返回结果，未命中时则在网络请求结果返回时更新缓存</li>
</ul>
<h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a><code>ConnectInterceptor</code></h4><ul>
<li>负责与服务器建立连接</li>
</ul>
<h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a><code>CallServerInterceptor</code></h4><ul>
<li>负责向服务器发送请求，从服务器读取返回结果</li>
</ul>
<p>环环相扣，是一个典型的责任链模式，这些<code>Interceptor</code>与我们平时写的简单的<code>Interceptor</code>本质是一样的，都是实现一个<code>intercept(Chain chain)</code>方法，然后在<code>Request</code>和<code>Response</code>上做文章，但是套在一起，就实现了一个完整的网络请求过程，同时还完成了重试、缓存这些工作。具体的代码就不分析了···因为具体发起请求和读取返回结果又是<code>HttpCodec</code>和<code>Okio</code>这两个大家伙的工作，分析起来又是大把的时间耗在里面了(都是泪)。有兴趣的同学可以读读看。如果只是分析<code>OkHttp</code>大的源码结构的话，这几个类就足够了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Drizzle Zhang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: undefined,
		mathjax: undefined,
		animate: undefined,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






  </div>
</body>
</html>